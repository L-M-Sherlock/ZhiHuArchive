<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>06 1989: SuperMemo 适应用户记忆(中) - @Thoughts Memo</title>
<meta charset="UTF-8">
<meta property="og:type" content="website">
<meta property="og:title" content="06 1989: SuperMemo 适应用户记忆(中) - @Thoughts Memo">
<meta property="og:site_name" content="ZhiHu Archive for Thoughts Memo">
<meta property="og:url" content="https://zhuanlan.zhihu.com/p/207094393">
<meta name="description" property="og:description" content="总目录：0 目录《间隔重复的历史》 上一章：06 1989: SuperMemo 适应用户记忆(上) 中…">
<meta property="twitter:card" content="summary">
<meta name="twitter:title" property="og:title" itemprop="name" content="06 1989: SuperMemo 适应用户记忆(中) - @Thoughts Memo">
<meta name="twitter:description" property="og:description" itemprop="description" content="总目录：0 目录《间隔重复的历史》 上一章：06 1989: SuperMemo 适应用户记忆(上) 中…">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no">
<meta name="google-site-verification" content="U7ZAFUgGNK60mmMqaRygg5vy-k8pwbPbDFXNjDCu7Xk" />
<link rel="alternate" type="application/rss+xml" title="ZhiHu Archive for Thoughts Memo" href="https://l-m-sherlock.github.io/ZhiHuArchive/feed.xml">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/yue.css@0.4.0/yue.css">
<script>
</script>
<style>
.origin_image {
width: 100%;
}
figure {
margin:1.4em 0;
}
figure img {
width: 100%;
}
img {
vertical-align: middle;
}
.author {
display: flex;
gap: 1em;
}
#avatar {
width: 100px;
height: 100px;
}
.author > div {
flex: 1;
}
a[data-draft-type="link-card"] {
   display: block;
}
</style>
</head>
<body style="max-width: 1000px; margin: 0 auto; padding: 0 1em 0 1em;" class="yue">
<p><a href="./">← 返回目录</a></p>
<hr>
<header>
<img class="origin_image" src="https://pica.zhimg.com/v2-0913a764622f1742797e4e7f0f693aed_720w.jpg?source=b1748391"/>
<h1><a href="https://zhuanlan.zhihu.com/p/207094393">06 1989: SuperMemo 适应用户记忆(中)</a></h1>
<div class="author">
<img class="avatar" id="avatar" src="https://picx.zhimg.com/50/v2-f958f2b875b0cf4d7ee853e4446ba2d1_l.jpg?source=b1748391" />
<div>
<h2 rel="author">
<a href="https://api.zhihu.com/people/4c592f496dc33822b560b382907ff1d0" target="_blank">@Thoughts Memo</a>
</h2>
<p> 学校≠教育≠技能；文凭溢价=80%信号传递+20%人力资本 </p>
</div>
</div>
<time datetime="2020-08-30T15:25:26">发表于 2020年08月30日</time>
<p rel="stats"style="color: #999; font-size: 0.9em;">18 👍 / 1 💬</p>
</header>
<article>
<p data-pid="BRbYvZeL">总目录：<a class="internal" href="https://zhuanlan.zhihu.com/p/375379522?">0 目录《间隔重复的历史》</a></p><p data-pid="fE6ijHRl">上一章：<a class="internal" href="./205600711.html">06 1989: SuperMemo 适应用户记忆(上)</a></p><p data-pid="CKCqaeZr">中篇主要介绍了 SuperMemo 5 的算法大纲、Anki 对 SM-5 算法的批评、博士对 Anki 批评的回应。</p><hr/><h2><b>SuperMemo 5</b></h2><p data-pid="OqZlSd6X">最优间隔矩阵的概念诞生于 1989 年 2 月 11 日。<a class="wrap external" href="https://supermemo.guru/wiki/SuperMemo" rel="nofollow noreferrer" target="_blank">SuperMemo</a>将为不同水平的记忆稳定性和难度保存一组最优间隔。它将根据新数据流修改间隔。1989 年 3 月 1 日，我开始使用 SuperMemo 4 来学习世界语。我很早就注意到这个想法需要全面修改。算法的收敛速度慢得要命。</p><p data-pid="WQaFonVf">1989 年 5 月 5 日，我有了一个新想法。从本质上讲，这就是<a class="wrap external" href="https://supermemo.guru/wiki/Stability_increase" rel="nofollow noreferrer" target="_blank">稳定性增长</a>函数的诞生，除了在 <a class="wrap external" href="https://supermemo.guru/wiki/SuperMemo" rel="nofollow noreferrer" target="_blank">SuperMemo</a> 的最优复习中没有<a class="wrap external" href="https://supermemo.guru/wiki/Retrievability" rel="nofollow noreferrer" target="_blank">可提取性</a>维度。新算法将使用<a class="wrap external" href="https://supermemo.guru/wiki/Matrix_of_optimum_factors" rel="nofollow noreferrer" target="_blank">最优因子矩阵</a>。它不会记住最优的时间间隔，而是记住需要根据<a class="wrap external" href="https://supermemo.guru/wiki/memory_%E5%A4%8D%E6%9D%82%E6%80%A7" rel="nofollow noreferrer" target="_blank">记忆复杂度</a>和当前<a class="wrap external" href="https://supermemo.guru/wiki/Memory_stability" rel="nofollow noreferrer" target="_blank">记忆稳定性</a>增加多少时间间隔。算法 SM-4 的缓慢收敛也激发了<a class="wrap external" href="https://supermemo.guru/wiki/History_of_spaced_repetition_(print)#randomization" rel="nofollow noreferrer" target="_blank">随机化间隔</a>的需求(1989年5月20日)。</p><p data-pid="B6TunMS8">与此同时，<a class="wrap external" href="https://supermemo.guru/wiki/SuperMemo" rel="nofollow noreferrer" target="_blank">SuperMemo</a> 的进展又一次因为学校的义务而被推迟。在 <a class="wrap external" href="https://supermemo.guru/wiki/Krzysztof_Biedalak" rel="nofollow noreferrer" target="_blank">Krzysztof Biedalak</a> 的帮助下，我们决定编写一个程序，用于开发可以与 SuperMemo 一起使用的学校测试。这个项目再次被用来在开明的 Krzysztof 博士的课堂上摆脱其他义务，Krzysztof 现在已经成为 SuperMemo 的支持者。</p><p data-pid="NtCBXzYs">我花了一个夏天在荷兰进行实践训练，由于各种义务(包括<b>强制</b>远足！)进展缓慢。速度慢的主要原因之一是极端节食，这是因为需要存钱来偿还我的 PC1512 债务。我还希望能多挣些钱给我的电脑买个硬盘。多亏了埃因霍温大学的 Peter Klijn 的帮助，我的所有工作才得以完成。他只是把他的电脑给了我，让我在整整两个月的时间里私人使用。他不想让我在 SuperMemo 上出色的工作慢下来。这是我第一次可以把所有的文件都保存在硬盘上，感觉就像是从一辆旧自行车搬到了特斯拉 S 型车。</p><p data-pid="d2b8ZxG-">直到 1989 年 10 月 16 日，新的算法 SM-5 才完成，我开始使用 SuperMemo 5。我在笔记中写道：“<i>一场伟大的革命即将到来</i>”。确实取得了巨大的进展。</p><p data-pid="ZfJbdFz5">我有几个 SuperMemo 2 的用户准备升级到 SuperMemo 5。我只要求一个条件：他们将从初始化为特定值的最优因子矩阵开始。这是为了验证算法，并确保它没有先入为主的偏见。所有预先设定的优化矩阵将很好地快速收敛。这一事实随后被用来主张普遍收敛，该算法在<a class="wrap external" href="https://supermemo.guru/wiki/Optimization_of_repetition_spacing_in_the_practice_of_learning" rel="nofollow noreferrer" target="_blank">关于间隔重复算法的第一本出版物</a>中被这样描述。不要读那份出版物！它已经被<a class="wrap external" href="https://supermemo.guru/wiki/Peer_review" rel="nofollow noreferrer" target="_blank">同行评审</a>阉割了。阅读下面的内容来理解 SM-5 算法。</p><h2><b>算法 SM-5</b></h2><p data-pid="tQsew4KY"><a class="wrap external" href="https://supermemo.guru/wiki/SuperMemo" rel="nofollow noreferrer" target="_blank">SuperMemo</a> 使用了一个简单的原则：<i>“使用、验证和纠正”</i>。在<a class="wrap external" href="https://supermemo.guru/wiki/Repetition" rel="nofollow noreferrer" target="_blank">重复</a>之后，在<a class="wrap external" href="https://supermemo.guru/wiki/OF_matrix" rel="nofollow noreferrer" target="_blank">OF 矩阵</a>的帮助下计算一个新的间隔。计算时间间隔的“相关项目”取决于重复(类别)和项目难度。在<a class="wrap external" href="https://supermemo.guru/wiki/Interval" rel="nofollow noreferrer" target="_blank">间隔时间</a>过后， SuperMemo 要求下一次重复。使用<a class="wrap external" href="https://supermemo.guru/wiki/Grade" rel="nofollow noreferrer" target="_blank">成绩</a>来告诉 SuperMemo 这个间隔“表现”得如何。如果成绩较低，我们有理由相信，间隔太长，<a class="wrap external" href="https://supermemo.guru/wiki/OF_matrix" rel="nofollow noreferrer" target="_blank">OF 矩阵</a> 对应的项太大。在这种情况下，我们稍微减少了对应的项。这里的相关项目是之前用于计算间隔（即在间隔开始之前）的项目。换句话说，项目（1）用于计算间隔（n 次重复之后），然后（2）用于纠正 <a class="wrap external" href="https://supermemo.guru/wiki/OF_matrix" rel="nofollow noreferrer" target="_blank">OF 矩阵</a>（n+1次重复之后）。</p><p data-pid="zuUKcRDu">以下是我的<a class="wrap external" href="https://supermemo.guru/wiki/Master%27s%20_thesis" rel="nofollow noreferrer" target="_blank">硕士论文</a>中给出的算法SM-5的概要:</p><blockquote data-pid="M91LqLA9">档案警告：<a class="wrap external" href="https://supermemo.guru/wiki/Why_use_literal_archives%3F" rel="nofollow noreferrer" target="_blank">为什么使用文字档案?</a><br/>本文是<a class="wrap external" href="https://supermemo.guru/wiki/Piotr_Wozniak" rel="nofollow noreferrer" target="_blank">Piotr Wozniak</a>(1990)的《<i>优化学习</i>》的一部分。</blockquote><p data-pid="rvOLGSnU"><b>SuperMemo 5算法的最终公式如下(算法SM-5):</b></p><ol><li data-pid="g_s_S6bQ">将知识分成尽可能小的项目</li><li data-pid="4uBzQ6Ew">所有项目的 <a class="wrap external" href="https://supermemo.guru/wiki/E-Factor" rel="nofollow noreferrer" target="_blank">E-Factor</a> 等于 2.5</li><li data-pid="wP8rF2S9">将不同重复次数和 EF 类别的矩阵制表。使用以下公式：</li><ol><li data-pid="ifaVMILn">OF(1,EF):=4</li><li data-pid="vuPoh5ef">for n&gt;1 OF(n,EF):=EF</li><li data-pid="28eBt3VV">其中：</li><ol><li data-pid="Y5c_acGL">OF(n,EF) - 对应给定简易度和连续复习次数 n 的最优因子</li></ol></ol><li data-pid="0rbjKKiJ">使用 OF 矩阵确定重复间隔：</li><ol><li data-pid="pLxGlAHW">I(n,EF)=OF(n,EF)*I(n-1,EF)</li><li data-pid="sfk20-9v">I(1,EF)=OF(1,EF)</li><li data-pid="3D0HOgSV">其中：</li><ol><li data-pid="xDL-TQ8D">I(n,EF) - 给定 EF 值的卡片的连续第 n 个间隔</li><li data-pid="hslLQlnE">OF(n,EF) - OF 矩阵对应给定简易度和连续复习次数 n 的 OF 值</li></ol></ol><li data-pid="kicAjtmE">在每次重复之后，在 0-5 级量表中评估<a class="wrap external" href="https://supermemo.guru/wiki/Grade" rel="nofollow noreferrer" target="_blank">成绩</a> (cf.算法SM-2)</li><li data-pid="oWl9r3m3">每次重复后，根据公式修改最近重复项的e因子：</li><ol><li data-pid="HBsYuM7y">EF':=EF+(0.1-(5-q)*(0.08+(5-q)*0.02))</li><li data-pid="v6q1spIE">其中：</li><ol><li data-pid="kDAV42oN">EF' -  简易度的新值</li><li data-pid="A8urirV8">EF - 简易度的旧值</li><li data-pid="K-HsHMi9">q - <a class="wrap external" href="https://supermemo.guru/wiki/Grade" rel="nofollow noreferrer" target="_blank">quality of the response</a> in the 0-5 grade scale</li></ol><li data-pid="i5we8u9U">如果 EF 小于 1.3，则将 EF 设置为 1.3</li></ol><li data-pid="YJC0ffaD">每次重复后修改矩阵的相关项目。任意构造并在修改中使用的示例性公式可以是这样的：</li><ol><li data-pid="VhAe3D1A">OF':=OF<i>(0.72+q</i>0.07)</li><li data-pid="kR5poPcE">OF<i>:=(1-fraction)*OF+fraction*OF'</i></li><li data-pid="BxY5l3ew">其中：</li><ol><li data-pid="az84-QNH">OF *- OF 的新值</li><li data-pid="1fUAdVtD">OF' -  计算 OF 新值的辅助值</li><li data-pid="hmXZBjBc">OF - OF 的旧值</li><li data-pid="QVnF3X9Y">fraction - 0~1之间的一个值，越大 OF 改变越大</li><li data-pid="1xSIz0kK">q - <a class="wrap external" href="https://supermemo.guru/wiki/Grade" rel="nofollow noreferrer" target="_blank">回忆质量打分</a> 0 - 5</li></ol><li data-pid="QjjRTPKE">请注意，对于 q=4 ，OF 不变。q&gt;4 时增大，q&lt;4 时减小。</li></ol><li data-pid="J9R1BtpD">如果 q 小于 3，则不改变 EF 的值，项目从头开始复习。</li><li data-pid="Duz1awB8">在某一天的每一次重复之后，重复所有在<a class="wrap external" href="https://supermemo.guru/wiki/Grade" rel="nofollow noreferrer" target="_blank">回忆质量打分</a>中得分低于 4 分的项目。继续<a class="wrap external" href="https://supermemo.guru/wiki/Repetition" rel="nofollow noreferrer" target="_blank">重复</a>，直到所有这些<a class="wrap external" href="https://supermemo.guru/wiki/Item" rel="nofollow noreferrer" target="_blank">项目</a>得分至少 4 分</li></ol><p data-pid="0Wwp690l">根据之前的观察，<a class="wrap external" href="https://supermemo.guru/wiki/OF_matrix" rel="nofollow noreferrer" target="_blank">OF 矩阵</a>的项不允许低于 1.2。在算法 SM-5 中，根据定义，<a class="wrap external" href="https://supermemo.guru/wiki/Interval" rel="nofollow noreferrer" target="_blank">间隔</a>不能在连续的<a class="wrap external" href="https://supermemo.guru/wiki/Repetition" rel="nofollow noreferrer" target="_blank">重复</a>中变得更短。时间间隔至少是其前身的 1.2 倍。更改 <a class="wrap external" href="https://supermemo.guru/wiki/E-Factor" rel="nofollow noreferrer" target="_blank">E-Factor</a> 类别仅增加下一个应用的间隔，增加的倍数与 <a class="wrap external" href="https://supermemo.guru/wiki/OF_matrix" rel="nofollow noreferrer" target="_blank">OF 矩阵</a>相应项所需的倍数相同。</p><h2><b>对 SM-5 算法的批评</b></h2><p data-pid="AnXHpu0h"><a class="wrap external" href="https://supermemo.guru/wiki/Anki" rel="nofollow noreferrer" target="_blank">Anki</a> 手册中包含了一段对 SM-5 算法出乎意料的批评(2018 年 4 月)。这些话特别令人惊讶，因为算法 SM-5 从来没有完整地发表过(上面的版本只是一个粗略的大纲)。尽管批评的话语显然是善意的，但它们暗示了一种可能性，即如果<a class="wrap external" href="https://supermemo.guru/wiki/Algorithm_SM-2" rel="nofollow noreferrer" target="_blank">算法 SM-2</a>是优于<a class="wrap external" href="https://supermemo.guru/wiki/Algorithm_SM-5" rel="nofollow noreferrer" target="_blank">算法 SM-5</a>，或许它也优于<a class="wrap external" href="https://supermemo.guru/wiki/Algorithm_SM-17" rel="nofollow noreferrer" target="_blank">算法 SM-17</a>。如果是这样的话，我就浪费了过去 30 年的研究和编程。时至今日，维基百科还在“批评” “<a class="wrap external" href="https://supermemo.guru/wiki/SM3%2B" rel="nofollow noreferrer" target="_blank">SM3+</a>”。“SM3+” 是最初在<a class="wrap external" href="https://supermemo.guru/wiki/Anki" rel="nofollow noreferrer" target="_blank">Anki</a>手册中使用的一个标签，已经在网络上的几十个站点使用(特别是那些因其简单性而倾向于坚持使用较旧算法的人)。<a class="wrap external" href="https://supermemo.guru/wiki/Universal_metric_for_cross-comparison_of_spaced_repetition_algorithms" rel="nofollow noreferrer" target="_blank">这里</a>比较了算法 SM-2 和算法 SM-17 。希望这不会有任何疑问。</p><h3><b>Anki 手册中的错误声明</b></h3><p data-pid="Na4nJeFe">我的<a class="wrap external" href="https://supermemo.guru/wiki/Master%27s%20_thesis" rel="nofollow noreferrer" target="_blank">硕士论文</a>于 1998 年在 <a class="wrap external" href="https://supermemo.com/" rel="nofollow noreferrer" target="_blank">supermemo.com</a> 上摘录发表，其中只包括对算法 SM-5 的粗略描述。为了清楚起见，数十个次要程序没有公布。这些程序需要进行大量修改，以确保良好的收敛性、稳定性和准确性。这种修修补补需要几个月的学习和分析相结合。算法 SM-5 从来没有现成的开箱即用版本。</p><p data-pid="q5Nau3Eo">算法 SM-5 的源代码从未发表或公开过，最初的算法只能在 MS DOS 下由 Supermemo 5 的用户进行测试。SuperMemo 5 在 1993 年成为免费软件。需要注意的是，围绕最优值的随机分散间隔是建立收敛性的关键。如果没有<a class="wrap external" href="https://supermemo.guru/wiki/History_of_spaced_repetition_(print)#%20random_dispersal_of_interval" rel="nofollow noreferrer" target="_blank">分散</a>，算法的进展将会慢得令人痛苦。同样，<a class="wrap external" href="https://supermemo.guru/wiki/History_of_spaced_repetition_(print)#%20Matrix_smoothing" rel="nofollow noreferrer" target="_blank">矩阵平滑</a>对于一致的行为是必要的，独立于为不同级别的<a class="wrap external" href="https://supermemo.guru/wiki/Stability" rel="nofollow noreferrer" target="_blank">稳定性</a>和项目<a class="wrap external" href="https://supermemo.guru/wiki/Complexity" rel="nofollow noreferrer" target="_blank">复杂性</a>收集的数据的稀缺性。</p><p data-pid="8vvQQlNr">在 1989 年和之后进行的多次评估表明，在任何研究的度量中，算法 SM-5 和之后的算法毫无疑问地优于<a class="wrap external" href="https://supermemo.guru/wiki/Algorithm_SM-2" rel="nofollow noreferrer" target="_blank">算法 SM-2</a>。算法 SM-17 实际上可以用来衡量算法 SM-5 的效率，如果我们有志愿者用我们的<a class="wrap external" href="https://supermemo.guru/wiki/Algorithm_SM-17" rel="nofollow noreferrer" target="_blank">通用度量</a>重新实现古老的代码。到目前为止，我们已经对 SM-2 算法进行了比较。实现的成本微不足道。不用说，SM-2 算法在预测能力方面远远落后，特别是在<a class="wrap external" href="https://supermemo.guru/wiki/Retrievability" rel="nofollow noreferrer" target="_blank">可提取性</a>的次优水平(在用户没有严格遵守规定时间表的情况下)。</p><p data-pid="KmQi1Gfa">即使对底层模型有基本的了解，也应该清楚一个好的实现将产生巨大的好处。SuperMemo 5 将根据用户的记忆来调整它的间隔函数。SuperMemo 2 是固定不变的。我非常自豪的是，1985年和1987年的大胆猜测经受住了时间的考验，但任何算法都不应该相信一个拥有 2 年间隔重复算法实现经验的卑微学生的判断。相反，Supermemo 4 和所有后续实现进行的猜测越来越少，并且提供了更好、更快的适应性。在所有这些实现中，只有 Supermemo 4 适应速度慢，并在 7 个月内被更好的解决方案取代。</p><p data-pid="6fCpcxDV">Anki 的批评没有恶意，但如果作者推动实施并迅速转向自学，而不是花时间修补那些似乎不像他预期的那样有效的程序，我不会感到惊讶。相比之下，在1989年，我知道算法SM-2是有缺陷的，我知道算法SM-5是更好的，我将不遗余力地确保新概念被完善到其最大的理论潜力。</p><blockquote data-pid="Y-PQIbsG">Anki 手册摘录(2018年4月):</blockquote><p data-pid="Bon41K_b">Anki最初是基于 SuperMemo 的 SM5 算法。然而，Anki 在回答卡片之前显示下一个间隔的默认行为揭示了 SM5 算法的一些基本问题。SM2 于后来修改的算法之间的关键区别是：</p><ul><li data-pid="5Nt7SIh_">SM2 根据您的一张卡片上的表现来安排该卡片下一次的时间</li><li data-pid="tfs26eyU">SM3+ 根据您的一张卡片上的表现来安排该卡片，以及类似卡片下一次的时间</li></ul><p data-pid="rvgP4U8Z">后一种方法不仅考虑了单个卡片的表现，还考虑了作为一个组的表现，从而保证了选择更准确的间隔时间。如果你在学习上非常一致，并且所有的牌都有一个非常相似的难度，这种方法可以很好地工作。然而，一旦在公式中引入了不一致性(不同难度的卡片，不是每天在同一时间学习)，SM3+ 更容易在下一个间隔中出现不正确的猜测——导致牌被安排得太频繁或太遥远。</p><p data-pid="Cr8Q6eLX">此外，当SM3+动态调整“最优因子”表时，经常会出现这样的情况：在一张卡片上回答“困难”比回答“容易”的间隔时间更长。下一次时间在 SuperMemo 中是隐藏的，所以用户永远不会知道这个。</p><p data-pid="C2zeGiZD">在对备选方案进行评估之后，Anki 的作者认为，通过模仿 SM2 产生的接近最优间隔要比冒着错误猜测的风险获得最优间隔更好。SM2 方法对用户来说是可预测的和直观的，而 SM3+ 方法对用户隐藏了细节，并要求用户信任系统(即使系统可能在调度中出错)</p><p data-pid="hKUk9Xm0">在所有这些说法中，只有一个是正确的。<a class="wrap external" href="https://supermemo.guru/wiki/SuperMemo_2" rel="nofollow noreferrer" target="_blank">SuperMemo 2</a> 确实更直观。多年来，这个问题一直困扰着 SuperMemo。每个版本都更复杂，很难向用户隐藏其中的某些复杂性。我们将继续努力。</p><p data-pid="UwnIEqJJ">这就是为什么 Anki 批评是不合理的原因：</p><ul><li data-pid="dGBMB944">事实上，SuperMemo 5 利用所有项目的过去表现来最大化新项目的表现，这是一个优势，而不是一个“问题”。更重要的是，这是适应性的关键<br/><br/></li><li data-pid="43eoElrX">不一致的评分一直是所有算法的一个问题。平均而言，适应性有助于发现错误评分的平均影响，特别是如果不一致本身是一致的(即用户在相似的情况下不断犯类似的错误)<br/><br/></li><li data-pid="E1Ulpg4s">混合的困难被 SuperMemo 5 处理得更好。在 SuperMemo 2 中难度和稳定性增长都是用 EF 编码的，而在 SuperMemo 5 及以后的版本中，这两种记忆特性是分开的<br/><br/></li><li data-pid="fdkO9Spq">间隔预测在 SuperMemo 5 中被证明更优越，而“更容易出错”的说法只能用实现中的错误来解释<br/><br/></li><li data-pid="nTUDbIr_">如果没有实现矩阵平滑，较低的评分可能带来更长的间隔。这部分算法在我的论文中只做了口头描述<br/><br/></li><li data-pid="SUjPRu7C">即使在更简单的实现中(例如，对于手持设备、智能手机等)，间隔和重复日期也总是显著地显示在 SuperMemo 中。没有向用户隐藏任何东西。最重要的是，遗忘指数和工作量的统计数据是完全可见的，并且有可能看到 SuperMemo 是否履行了它承诺的保留，以及在怎样的工作量代价下。<br/><br/></li><li data-pid="wISQaiba">算法及其所有细节在 SuperMemo 5 中得到了充分的展示。特别是，在每次重复时将显示对矩阵的更改。对于任何对算法有基本了解的人来说，它的操作都是完全透明的。全面的跟踪也可以在 Anki 或其他应用程序中实现，但可能需要大量的修改。这将是昂贵的。最后，Anki 的选择可能确实很好，因为它很简单(从实现、操作、跟踪、调试、维护、用户直觉等方面来说)。<br/><br/></li><li data-pid="AnoNJtvF">“隐藏细节”的抱怨与神经网络在间隔重复方面更优越的主张是截然相反的。与神经网络实现不同，算法SM-5的操作比较容易分析</li></ul><p data-pid="20p7IkHI">我们 2011 年在 <a class="wrap external" href="http://supermemopedia.com/" rel="nofollow noreferrer" target="_blank">supermemopedia.com</a> 上发表的官方回应今天看来相当准确:</p><blockquote data-pid="SISYeFcb">档案警告：<a class="wrap external" href="https://supermemo.guru/wiki/Why_use_literal_archives%3F" rel="nofollow noreferrer" target="_blank">为什么使用文字档案?</a></blockquote><p data-pid="ERubMNGc">很棒的是，Anki 介绍了自己的创新，同时仍然给予 SuperMemo 应有的赞誉。的确，与莱特纳系统或纸面上的 Supermemo 相比，SuperMemo 的算法 SM-2 工作得很好。然而，SM-5 算法相对于 SM-2 算法的优越性是毋庸置疑的。无论是在实践中还是在理论上都是如此。算法 SM-2 的时间间隔是固定的，并且只依赖于项目的难度，该难度可以用一个启发式公式来近似(即一个基于 1987 年前有限经验得出的猜测的公式)。确实，您不能通过向算法 SM-2 提供错误数据来“破坏”它。之所以如此，只是因为它不具有适应性。您可能更喜欢使用可自定义字体的文字处理程序，尽管您可能会通过应用修饰把文本弄乱。</p><p data-pid="pwKWY4SP">SM-2算法简单地用一个所谓的 <a class="wrap external" href="https://supermemo.guru/wiki/E-Factor" rel="nofollow noreferrer" target="_blank">E-Factor</a> 来粗略地乘以间隔，这是一种表示项目<a class="wrap external" href="https://supermemo.guru/wiki/%E9%9A%BE%E5%BA%A6" rel="nofollow noreferrer" target="_blank">难度</a>的方法。相反，算法 SM-5 收集用户的表现数据，并相应地修改最优间隔的函数。换句话说，它适应学生的表现。算法 SM-6 甚至更进一步，修改了最优间隔的函数，以达到期望的<a class="wrap external" href="https://supermemo.guru/wiki/Knowledge_retention" rel="nofollow noreferrer" target="_blank">知识保留</a>水平。这些新算法的优越性已经通过多种方式得到了验证，例如，通过测量固定大小数据库中工作负载随时间的下降情况。在研究的案例中（小样本），与使用算法 SM-2 处理的旧数据库（相同类型的材料：英语词汇）相比，使用新算法处理的工作量下降速度几乎是后者的两倍。</p><p data-pid="ISk02R90">所有的 SuperMemo 算法都将项目分成难度类别。算法 SM-2 给每个类别一个严格的间隔集。算法 SM-5 也给了每个类别一组间隔，但是这些间隔是根据用户的表现来调整的，也就是说不是固定不变的。</p><p data-pid="qBpoX0T0">“糟糕的评分”在算法 SM-5 中确实比在算法 SM-2 中更严重，因为错误的数据会导致“错误的适应”。然而，在 SuperMemo 中给出不真实/作弊的分数总是不好的，无论你使用哪种算法。</p><p data-pid="sKAhGDVK">在有关记忆的知识不完整的情况下，适应性总是优于僵化的模型。这就是为什么适应一个不精确的平均值（如算法SM-5）要比根据一个不精确的猜测（如算法 SM-2）来确定间隔要好。 毋庸置疑，最后一个词进入算法 SM-8 之后又变了，因为它适应了测得的平均值。</p><hr/><p data-pid="Sf1-GzSS">下篇会给出 SM-5 更优越的数据和理论证明，以及 SM-5 算法的其它改进细节。</p><p data-pid="qB6I9UGP">下一章：<a class="internal" href="./213170503.html">06 1989: SuperMemo 适应用户记忆(下)</a></p>

<hr>
<div class="column" style="margin: 1em 0; padding: 0.5em 1em; border: 2px solid #999; border-radius: 5px;">
<h2>专栏：学校教育问题</h2>
</div>
<hr>
<p><a href="./">← 返回目录</a></p>
</article>
<script src="https://giscus.app/client.js"
data-repo="L-M-Sherlock/ZhiHuArchive"
data-repo-id="MDEwOlJlcG9zaXRvcnkzNDk5NDE0MzM="
data-category="Announcements"
data-category-id="DIC_kwDOFNuuuc4Ck92x"
data-mapping="title"
data-strict="0"
data-reactions-enabled="1"
data-emit-metadata="0"
data-input-position="top"
data-theme="preferred_color_scheme"
data-lang="zh-CN"
data-loading="lazy"
crossorigin="anonymous"
async>
</script>
</body>
</html>