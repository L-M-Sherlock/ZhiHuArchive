<meta charset="UTF-8">
06 1989: SuperMemo 适应用户记忆(上)
<p>本文主要介绍 SM-4 和 SM-5，由于内容实在太长了，这里拆成上中下三篇。</p><p>上篇主要讲 SM-4 为啥被提出、实际效果如何、带来哪些启发。</p><hr><h2><b>Introducing flexible interval function</b></h2><h2><b>引入弹性间隔函数</b></h2><p><u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/SuperMemo_2" class=" wrap external" target="_blank" rel="nofollow noreferrer">SuperMemo 2</a></u> was great. Its simple algorithm has <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Exponential_growth_of_the_popularity_of_Algorithm_SM-2" class=" wrap external" target="_blank" rel="nofollow noreferrer">survived in various mutations to this day</a></u> in popular apps such as <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Anki" class=" wrap external" target="_blank" rel="nofollow noreferrer">Anki</a></u> or <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Mnemosyne" class=" wrap external" target="_blank" rel="nofollow noreferrer">Mnemosyne</a></u>. However, the algorithm was dumb in the sense that there was no way of modifying the function of <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Optimum_interval" class=" wrap external" target="_blank" rel="nofollow noreferrer">optimum intervals</a></u>. The findings of <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Birthday_of_SuperMemo" class=" wrap external" target="_blank" rel="nofollow noreferrer">1985</a></u> were set in stone. Memory <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Complexity" class=" wrap external" target="_blank" rel="nofollow noreferrer">complexity</a></u> and <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Stability_increase" class=" wrap external" target="_blank" rel="nofollow noreferrer">stability increase</a></u> were expressed with the same single number: <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/E-factor" class=" wrap external" target="_blank" rel="nofollow noreferrer">E-factor</a></u>. It is a bit like using a single lever in a bike to change gears, and the direction of driving.</p><p><u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/SuperMemo_2" class=" wrap external" target="_blank" rel="nofollow noreferrer">SuperMemo 2</a></u> 很棒。它的简单算法已经在流行的应用程序（如<u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Anki" class=" wrap external" target="_blank" rel="nofollow noreferrer">Anki</a></u>或<u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Mnemosyne" class=" wrap external" target="_blank" rel="nofollow noreferrer">Mnemosyne</a></u>）中<u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/exponential_growth_of_the_popular" class=" wrap external" target="_blank" rel="nofollow noreferrer">存活至今</a></u>。然而，该算法是愚蠢的，因为其没有办法修改<u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Optimum_interval" class=" wrap external" target="_blank" rel="nofollow noreferrer">最优间隔</a></u>的函数。<u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Birthday_of_SuperMemo" class=" wrap external" target="_blank" rel="nofollow noreferrer">1985</a></u> 的发现是板上钉钉的。记忆<u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Complexity" class=" wrap external" target="_blank" rel="nofollow noreferrer">复杂度</a></u>和<u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Stability_increase" class=" wrap external" target="_blank" rel="nofollow noreferrer">稳定性增加</a></u>用相同的数字表示：<u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/E-factor" class=" wrap external" target="_blank" rel="nofollow noreferrer">E-factor</a></u>。这有点像在自行车上使用同一个控制杆来改变档位和方向。</p><p>Individual <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Item" class=" wrap external" target="_blank" rel="nofollow noreferrer">items</a></u> could adapt the spacing of review by changes to their estimated <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Complexity" class=" wrap external" target="_blank" rel="nofollow noreferrer">difficulty</a></u>. Those changes could compensate for errors in the function of <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Optimum_interval" class=" wrap external" target="_blank" rel="nofollow noreferrer">optimum intervals</a></u>. Even if the algorithm was slow to converge on the optimum, in theory, it was convergent. The main flaw was that, in <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Algorithm_SM-2" class=" wrap external" target="_blank" rel="nofollow noreferrer">Algorithm SM-2</a></u>, new items would not benefit from the experience of old items.</p><p>单个的<u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Item" class=" wrap external" target="_blank" rel="nofollow noreferrer">项目</a></u>可以根据其估计的<u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Complexity" class=" wrap external" target="_blank" rel="nofollow noreferrer">难度</a></u>来调整复习的间隔。这些变化可以补偿<u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Optimum_interval" class=" wrap external" target="_blank" rel="nofollow noreferrer">最优间隔</a></u>函数中的错误。即使算法收敛速度慢，理论上也是收敛的。主要的缺陷是，在<u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Algorithm_SM-2" class=" wrap external" target="_blank" rel="nofollow noreferrer">算法 SM-2</a></u> 中，新项目不会从旧项目的经验中受益。</p><p><u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Algorithm_SM-2" class=" wrap external" target="_blank" rel="nofollow noreferrer">Algorithm SM-2</a></u> is not adaptable. New <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Item" class=" wrap external" target="_blank" rel="nofollow noreferrer">items</a></u> do not benefit from the experience of old items</p><p><u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Algorithm_SM-2" class=" wrap external" target="_blank" rel="nofollow noreferrer">算法 SM-2</a></u> 没有适应能力。新<u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Item" class=" wrap external" target="_blank" rel="nofollow noreferrer">项目</a></u>不受益于旧项目的经验</p><p>Algorithm SM-4 was the first attempt to arm <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/SuperMemo" class=" wrap external" target="_blank" rel="nofollow noreferrer">SuperMemo</a></u> with universal adaptability. It was completed in February 1989. In the end, adaptability was too slow to show up, but inspiration gathered with Algorithm SM-4 was essential for further progress, esp. in understanding the problem of stability-vs-accuracy in <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Spaced_repetition" class=" wrap external" target="_blank" rel="nofollow noreferrer">spaced repetition</a></u>. In short, Algorithm SM-4 was too stable to be accurate. This was quickly remedied in Algorithm SM-5 just 7 months later. Here is an excerpt from my <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Master%2527s_Thesis" class=" wrap external" target="_blank" rel="nofollow noreferrer">Master's Thesis</a></u> to explain the details:</p><p>算法 SM-4 是第一次尝试用通用的适应性武装 <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/SuperMemo" class=" wrap external" target="_blank" rel="nofollow noreferrer">SuperMemo</a></u>。它于 1989 年 2 月竣工。最后，适应性表现得太慢了，但是用算法 SM-4 收集的灵感对于进一步发展是至关重要的，特别是在理解<u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Spaced_repetition" class=" wrap external" target="_blank" rel="nofollow noreferrer">间隔重复</a></u>中的稳定性与准确性问题上。简而言之，SM-4 算法太过稳定而不能准确。这在 7 个月后的 SM-5 算法中很快得到了纠正。以下是我的<u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Master%2527s%2520Thesis" class=" wrap external" target="_blank" rel="nofollow noreferrer">硕士论文</a></u>的一段摘录。</p><blockquote>Archive warning: <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Why_use_literal_archives%253F" class=" wrap external" target="_blank" rel="nofollow noreferrer">Why use literal archives?</a></u><br>档案警告:<u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Why_use_literal_archives%253F" class=" wrap external" target="_blank" rel="nofollow noreferrer">为什么使用文字档案?</a></u><br>This text was part of: "<i>Optimization of learning</i>" by <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Piotr_Wozniak" class=" wrap external" target="_blank" rel="nofollow noreferrer">Piotr Wozniak</a></u> (1990)<br>本文是 <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Piotr_Wozniak" class=" wrap external" target="_blank" rel="nofollow noreferrer">Piotr Wozniak</a></u> 的《<i>优化学习</i>》(1990)的一部分。</blockquote><p>The main fault of <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Algorithm_SM-2" class=" wrap external" target="_blank" rel="nofollow noreferrer">Algorithm SM-2</a></u> seems to have been the arbitrary shape of the function of optimal intervals. Although very effective in practice and confirmed by years of experimental repetitions, <b>this function could not claim scientifically proved validity</b>, nor could it detect the overall impact of few day variations of optimal intervals on the learning process. Bearing these flaws in mind I decided to employ routine SuperMemo repetitions in the validation of the function of optimal intervals!</p><p><u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Algorithm_SM-2" class=" wrap external" target="_blank" rel="nofollow noreferrer">算法 SM-2</a></u> 的主要错误似乎是最优间隔函数的任意形状。虽然在实践中非常有效，并且经过多年的实验重复得到了证实，但是<b>这个函数并不能被科学地证明其有效性</b>，也不能检测出最优间隔的几天变化对学习过程的整体影响。考虑到这些缺陷，我决定使用常规的 SuperMemo 重复来验证最优间隔的作用!</p><p>Using optimization procedures like those applied in finding <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/E-Factor" class=" wrap external" target="_blank" rel="nofollow noreferrer">E-Factors</a></u> I wanted the program to correct the initially proposed function whenever corrections appeared justified.</p><p>使用那些在寻找<u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/E-Factor" class=" wrap external" target="_blank" rel="nofollow noreferrer">E因子</a></u>时应用的优化过程，我想让程序在任何时候修正最初提出的函数，只要修正看起来是合理的。</p><p>To achieve this goal, I tabulated the function of optimal intervals.</p><p>为了达到这个目的，我把最优间隔的函数列成表。</p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-d712c6a6552f57a19dbe5b84fe3f0f8b_720w.jpg?source=3af55fa1" data-caption="" data-size="normal" data-rawwidth="746" data-rawheight="600" class="origin_image zh-lightbox-thumb" width="746" data-original="https://pic3.zhimg.com/v2-d712c6a6552f57a19dbe5b84fe3f0f8b_720w.jpg?source=3af55fa1"></figure><blockquote><b>Figure:</b> Matrix of optimal intervals showed up in SuperMemo 4 in 1989, and survived to this day in SuperMemo 17 with few changes. In SuperMemo 4, it was the source of information for optimum spacing. In SuperMemo 17, it is derived from the OF matrix generated by Algorithm SM-15 that is used concurrently with Algorithm SM-17. The picture presents a matrix from SuperMemo 5, and shows a significant departure from the original values of the matrix. In SuperMemo 4, adaptations proceeded at much slower pace<br><b>图片：</b>最优间隔矩阵出现在1989年的SuperMemo 4中，并在SuperMemo 17中保留至今，几乎没有变化。在SuperMemo 4中，它是优化间距的信息来源。在SuperMemo 17中，它是由算法SM-15生成的矩阵得到的，同时与算法SM-17使用。这幅图展示了一个来自SuperMemo 5的矩阵，并显示了与原始矩阵值的显著偏离。在SuperMemo 4中，改编的速度要慢得多</blockquote><p>Particular entries of the matrix of optimal intervals (later called the OI matrix) were initially taken from the formulas used in Algorithm SM-2.</p><p>最优间隔矩阵(后来称为OI矩阵)的初始项最初取自算法SM-2中的公式。</p><p>SuperMemo 4 (February 1989), in which the new solution was implemented, used the OI matrix to determine values of inter-repetition intervals:</p><p>SuperMemo 4(1989年2月)实现了新的解决方案，使用OI矩阵来确定重复间隔的值:</p><p>I(n):=OI(n,EF)</p><p>where:</p><ul><li>I(n) - the n-th inter-repetition interval of a given item (in days),</li><li>EF - E-Factor of the item,</li><li>OI(n,EF) - the entry of the OI matrix corresponding to the n-th repetition and the E-Factor EF.</li></ul><p>上式中：</p><ul><li>I(n) - 给定项目的第n次重复间隔(以天为单位)，</li><li>EF - 项目的E-Factor，</li><li>OI(n,EF) - OI矩阵中对应第 n 次重复和 EF 的项目。</li></ul><p><br>However, the OI matrix was not fixed once for all. In the course of repetitions, particular entries of the matrix were increased or decreased depending on the grades. For example, if the entry indicated the optimal interval to be X and the used interval was X+Y while the grade after this interval was not lower than four, then the new value of the entry would fall between X and X+Y.</p><p>然而，OI 矩阵并不是固定的。在重复的过程中，矩阵的具体项随着分数的不同而增加或减少。例如，如果项目指出最优的间隔是 X，使用的间隔是 X+Y，而这个间隔之后的等级不低于 4，那么项目的新值将落在 X 和 X+Y 之间。</p><p>Thus the values of the OI entries in the equilibrium state should settle at the point where the stream of poor-retention items balances the stream of good-retention items in its influence on the matrix.</p><p>因此，处于平衡状态的 OI 项的值应该稳定在一个点上，在这个点上，低保留项流与高保留项流对矩阵的影响相平衡。</p><p>As a consequence, SuperMemo 4 was intended to yield an ultimate definition of the function of optimal intervals.</p><p>因此，SuperMemo 4 试图给出最优间隔函数的最终定义。</p><h2><b>Rigid SuperMemo 4</b></h2><h2><b>刚性 SuperMemo 4</b></h2><p>It did not take me long to realize that the verification-correction cycle in the new algorithm was too long. It was not much different than running the <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Birth_of_SuperMemo" class=" wrap external" target="_blank" rel="nofollow noreferrer">1985 eperiment</a></u> on the computer. To determine decade-long intervals, I needed a decade to pass to test the outcomes of the review. This led to <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Algorithm_SM-5" class=" wrap external" target="_blank" rel="nofollow noreferrer">Algorithm SM-5</a></u> seven months later. Here is the problem with Algorithm SM-4 as described in my <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Master%2527s_Thesis" class=" wrap external" target="_blank" rel="nofollow noreferrer">Master's Thesis</a></u>:</p><p>我很快就意识到新算法的验证-校正周期太长了。这与在计算机上运行 <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Birth_of_SuperMemo" class=" wrap external" target="_blank" rel="nofollow noreferrer">1985 年实验</a></u>没有太大的不同。为了确定十年的间隔，我需要十年的时间来测试审查的结果。这导致了七个月后的 <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Algorithm_SM-5" class=" wrap external" target="_blank" rel="nofollow noreferrer">算法 SM-5</a></u>。以下是我在<u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Master%2527s%2520_thesis" class=" wrap external" target="_blank" rel="nofollow noreferrer">硕士论文</a></u>中描述的算法 SM-4 的问题:</p><blockquote>Archive warning: <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Why_use_literal_archives%253F" class=" wrap external" target="_blank" rel="nofollow noreferrer">Why use literal archives?</a></u><br>档案警告:<u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Why_use_literal_archives%253F" class=" wrap external" target="_blank" rel="nofollow noreferrer">为什么使用文字档案?</a></u><br>This text was part of: "<i>Optimization of learning</i>" by <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Piotr_Wozniak" class=" wrap external" target="_blank" rel="nofollow noreferrer">Piotr Wozniak</a></u> (1990)<br>本文是 <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Piotr_Wozniak" class=" wrap external" target="_blank" rel="nofollow noreferrer">Piotr Wozniak</a></u> 的《<i>优化学习</i>》(1990)的一部分。</blockquote><p>Algorithm SM-4 was implemented in SuperMemo 4 and was used between March 9, 1989 and October 17, 1989. Although the main concept of modifying the function of optimal intervals seemed to be a major step forward, the implementation of the algorithm was a failure. The basic insufficiency of the algorithm appeared to result from formulas applied in modification of the OI matrix.</p><p>算法 SM-4 在 SuperMemo 4 中实现，并在 1989 年 3 月9 日至 1989 年 10 月 17 日期间使用。虽然修改最优间隔函数的主要概念似乎是向前迈出的一大步，但是算法的实现是失败的。该算法的基本不足似乎源于在修改OI矩阵时应用的公式。</p><p>There were two the most striking flaws:</p><ul><li>modifications were too subtle to rearrange the OI matrix visibly in a reasonably short time,</li><li>for longer inter-repetition intervals, the effect of modification had to wait very long before being steadily fixed, i.e. it took quite a lot of time before the result of a modification of a few-month-long interval could be seen and corrected if necessary</li></ul><p>有两个最明显的缺陷:</p><ul><li>修改太过细微，无法在合理的短时间内明显地重新排列 OI 矩阵，</li><li>对于较长的间隔重复时间，修改的效果需要很长时间才能稳定固定，即需要很长时间才能看到几个月间隔修改的结果，并在必要时进行修正</li></ul><p>After seven months of using Algorithm SM-4, the OI matrices of particular databases did not look much different from their initial states. One could explain this fact by the correctness of my earlier predictions concerning the real values of the optimal inter-repetition intervals, however, as it was later proved by means of <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Algorithm_SM-5" class=" wrap external" target="_blank" rel="nofollow noreferrer">Algorithm SM-5</a></u>, the actual reason of the stability of the matrices was the flaws in the optimization formulae.<br>在使用 SM-4 算法 7 个月后，特定数据库的 OI 矩阵与它们的初始状态并没有太大的不同。人们可以用我早先关于最优重复间隔真值的预测的正确性来解释这一事实，然而，正如后来用算法SM-5证明的那样，矩阵稳定的实际原因是优化公式中的缺陷。<br>As far as acquisition rate and retention are concerned, there is no reliable evidence that Algorithm SM-4 brought any progress. Slight improvement could as well be related to general betterment of the software and improvement in <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/20_rules" class=" wrap external" target="_blank" rel="nofollow noreferrer">item formulation principles</a></u><br>就获取率和保留率而言，没有可靠的证据表明 SM-4 算法带来了任何进展。轻微的改进也可能与软件的总体改进和项目制定原则的改进有关。</p><h2><b>Remnants of SuperMemo 4 in new SuperMemos</b></h2><h2><b>SuperMemo4 的残余在新的 SuperMemo 里</b></h2><p>Interestingly, you can still see the matrix of optimum intervals in newer versions of SuperMemo. The matrix is not used by the algorithm, however, it is displayed in SuperMemo statistics as it informs the user about the impact of <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Complexity" class=" wrap external" target="_blank" rel="nofollow noreferrer">complexity</a></u> on the prospects of items in the learning process.</p><p>有趣的是，你仍然可以在新版本的 SuperMemo 中看到最优间隔矩阵。这个矩阵并没有被算法使用，但是它显示在SuperMemo 统计数据中，因为它告诉用户<u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Complexity" class=" wrap external" target="_blank" rel="nofollow noreferrer">复杂性</a></u>对学习过程中项目的前景的影响。</p><p>If you compare a matrix produced by <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/SuperMemo_5" class=" wrap external" target="_blank" rel="nofollow noreferrer">SuperMemo 5</a></u> in 8 months of use, you will notice significant similarity to the matrix produced in two decades of using <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Algorithm_SM-8" class=" wrap external" target="_blank" rel="nofollow noreferrer">Algorithm SM-8</a></u>:</p><p>如果你比较一个使用了 8 个月的 <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/SuperMemo_5" class=" wrap external" target="_blank" rel="nofollow noreferrer">SuperMemo 5</a></u> 生成的矩阵，你会发现它与使用了 20 年的<u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Algorithm_SM-8" class=" wrap external" target="_blank" rel="nofollow noreferrer">算法 SM-8</a></u> 生成的矩阵有显著的相似性：</p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-64046a8ba999034b683e4246318e77f0_720w.jpg?source=3af55fa1" data-caption="" data-size="normal" data-rawwidth="800" data-rawheight="470" class="origin_image zh-lightbox-thumb" width="800" data-original="https://pic1.zhimg.com/v2-64046a8ba999034b683e4246318e77f0_720w.jpg?source=3af55fa1"></figure><blockquote><b>Figure:</b> Matrix of optimum intervals is no longer used in Algorithm SM-17. However, it can still be generated with procedures of Algorithm SM-15. The columns correspond with easiness of the material expressed as A-Factor. The rows correspond with memory stability expressed as repetition category<br><b>图片：</b>算法 SM-17 不再使用最优间隔矩阵。但是，仍然可以通过算法 SM-15 的步骤来生成。这些列与以A因子表示的材料的简易度相一致。这些行对应于以重复类别表示的记忆稳定性</blockquote><h2><b>Algorithm SM-4</b></h2><h2><b>算法SM-4</b></h2><p>Here is the outline of Algorithm SM-4 as described in my <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Master%2527s_Thesis" class=" wrap external" target="_blank" rel="nofollow noreferrer">Master's Thesis</a></u>:</p><p>以下是我在<u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Master%2527s%2520_thesis" class=" wrap external" target="_blank" rel="nofollow noreferrer">硕士论文</a></u>中描述的算法SM-4的概要:：</p><blockquote>Archive warning: <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Why_use_literal_archives%253F" class=" wrap external" target="_blank" rel="nofollow noreferrer">Why use literal archives?</a></u><br>档案警告:<u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Why_use_literal_archives%253F" class=" wrap external" target="_blank" rel="nofollow noreferrer">为什么使用文字档案?</a></u><br>This text was part of: "<i>Optimization of learning</i>" by <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Piotr_Wozniak" class=" wrap external" target="_blank" rel="nofollow noreferrer">Piotr Wozniak</a></u> (1990)<br>本文是 <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Piotr_Wozniak" class=" wrap external" target="_blank" rel="nofollow noreferrer">Piotr Wozniak</a></u>(1990) 的《<i>优化学习</i>》的一部分。<br><b>Algorithm SM-4 used in SuperMemo 4.0</b>:</blockquote><ol><li>Split the knowledge into smallest possible items</li><li>With all items associate an <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/E-Factor" class=" wrap external" target="_blank" rel="nofollow noreferrer">E-Factor</a></u> equal to 2.5</li><li>Tabulate the OI matrix for various repetition numbers and E-Factor categories</li><li>Use the following repetition spacing to obtain the initial OI matrix:</li><ol><li>OI(1,EF)=1</li><li>OI(2,EF)=6</li><li>for n&gt;2 OI(n,EF)=OI(n-1,EF)*EF</li><ol><li>OI(n,EF) - optimal inter-repetition interval after the n-th repetition (in days) for items with E-Factor equal EF,</li></ol></ol><li>Use the OI matrix to determine inter-repetition intervals:</li><ol><li>I(n, EF) = OI(n, EF)</li><ol><li>I(n,EF) - the n-th inter-repetition interval for an item whose E-Factor equals EF (in days),</li><li>OI(n,EF) - the entry of the OI matrix corresponding to the n-th repetition and the E-Factor EF</li></ol></ol><li>After each repetition estimate the <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Grade" class=" wrap external" target="_blank" rel="nofollow noreferrer">quality of the repetition response</a></u> in the 0-5 grade scale (see <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Algorithm_SM-2" class=" wrap external" target="_blank" rel="nofollow noreferrer">Algorithm SM-2</a></u>).</li><li>After each repetition modify the E-Factor of the recently repeated item according to the formula:</li><ol><li><img src="https://www.zhihu.com/equation?tex=EF%27%3DEF%2B%280.1-%285-q%29%5Ctimes%280.08%2B%285-q%29%5Ctimes0.02%29%29" alt="EF'=EF+(0.1-(5-q)\times(0.08+(5-q)\times0.02))" eeimg="1"> </li><ol><li>EF' - new value of the E-Factor,</li><li>EF - old value of the E-Factor,</li><li>q - quality of the response in the 0-5 grade scale.</li></ol><li>If EF is less than 1.3 then let EF be 1.3.</li></ol><li>After each repetition modify the relevant entry of the OI matrix.</li><li>An exemplary formula could look as follows (the actual formula used in SuperMemo 4 was more intricate):</li><ol><li><img src="https://www.zhihu.com/equation?tex=OI%27%3Dinterval%2B%5Ccfrac%7Binterval%5Ctimes+%281-%5Ccfrac%7B1%7D%7BEF%7D%29%7D%7B2%7D%5Ctimes%280.25%5Ctimes+q-1%29" alt="OI'=interval+\cfrac{interval\times (1-\cfrac{1}{EF})}{2}\times(0.25\times q-1)" eeimg="1"> </li><li><img src="https://www.zhihu.com/equation?tex=OI%27%27%3D%281-fraction%29%5Ctimes+OI%2Bfraction%5Ctimes+OI%27" alt="OI''=(1-fraction)\times OI+fraction\times OI'" eeimg="1"> </li><ol><li>OI <i>- new value of the OI entry,</i></li><li>OI' - auxiliary value of the OI entry used in calculations,</li><li>OI - old value of the OI entry,</li><li>interval - interval used before the considered repetition (i.e. the last used interval for the given item),</li><li>fraction - any number between 0 and 1 (the greater it is the faster the changes of the OI matrix),</li><li>EF - E-Factor of the repeated item,</li><li>q - quality of the response in the 0-5 grade scale.</li></ol><li>Note that for q=4 the OI does not change and that for q=5 the OI increases 4 times less than it decreases for q=0.</li><li>Note also that the maximum change of the OI equals (I(n)-I(n-1))/2 in terms of the repetition spacing used in Algorithm SM-2 (i.e. (OI-OI/EF)/2).</li></ol><li>If the quality response was lower than 3 then start repetitions for the item from the beginning without changing the E-Factor.</li><li>After each repetition session of a given day repeat again all the items that scored below four in the quality assessment. Continue the repetitions until all of these items score at least four</li></ol><p><b>算法SM-4在SuperMemo4.0中的应用</b><br></p><ol><li><b>算法</b><br></li><ol><li>将知识分解为最小的卡片</li><li>所有卡片的 EF 设置为 2.5</li><li>列出以重复次数和 EF 为索引的 OI 矩阵</li><li>使用下面的重复间隔来初始化 OI 矩阵：</li><ol><li>OI(1,EF)=1</li><li>OI(2,EF)=6</li><li>for n&gt;2 OI(n,EF)=OI(n-1,EF)*EF</li><ol><li>OI(n,EF) - 难度为 EF 的卡片在第 n 次复习时的最优间隔</li></ol></ol><li>使用 OI 矩阵来确定重复间隔：</li><ol><li>I(n, EF) = OI(n, EF)</li><li>I(n, EF) - 难度为 EF 的卡片在第 n 次复习时的间隔</li><li>OI(n, EF) - OI 矩阵对应 n 和 EF 的值</li></ol><li>每次重复后都用 0-5 的成绩来给回忆质量打分</li><li>每次重复后都根据下列公式修改 EF：</li><ol><li><img src="https://www.zhihu.com/equation?tex=EF%27%3DEF%2B%280.1-%285-q%29%5Ctimes%280.08%2B%285-q%29%5Ctimes0.02%29%29" alt="EF'=EF+(0.1-(5-q)\times(0.08+(5-q)\times0.02))" eeimg="1"> </li><ol><li>EF' - EF 的新值</li><li>EF - EF 的旧值</li><li>q - 回忆质量打分</li></ol><li>如果 EF &lt; 1.3 则令 EF = 1.3</li></ol><li>每次重复后都修改 OI 矩阵上的相关项</li><li>一个示例公式如下（SM-4 中实际使用的公式更复杂）：</li><ol><li><img src="https://www.zhihu.com/equation?tex=OI%27%3Dinterval%2B%5Ccfrac%7Binterval%5Ctimes+%281-%5Ccfrac%7B1%7D%7BEF%7D%29%7D%7B2%7D%5Ctimes%280.25%5Ctimes+q-1%29" alt="OI'=interval+\cfrac{interval\times (1-\cfrac{1}{EF})}{2}\times(0.25\times q-1)" eeimg="1"> </li><li><img src="https://www.zhihu.com/equation?tex=OI%27%27%3D%281-fraction%29%5Ctimes+OI%2Bfraction%5Ctimes+OI%27" alt="OI''=(1-fraction)\times OI+fraction\times OI'" eeimg="1"> </li><ol><li>OI - OI 对应项的旧值</li><li>OI' - 计算 OI 对应项新值的辅助值</li><li>OI'' - OI 对应项的新值</li><li>interval - 之前的间隔</li><li>fraction - 调和参数</li><li>EF - 重复卡片的 EF</li><li>q - 回忆质量评分</li></ol><li>注意，当 q = 4 时 OI 不会改变，当 q = 5 时 OI 增长是 q = 0 时减少的 4 分之一</li></ol><li>如果回忆质量小于 3，卡片重新开始复习，并且不改变其 EF</li><li>在某一天的每次重复练习之后，再重复那些在回忆质量评分中得分低于4分的卡片。继续重复，直到所有这些卡片得分至少4分。</li></ol></ol><h2><b>Problems with interval matrix</b></h2><h2><b>间隔矩阵的问题</b></h2><p>In addition to slow convergence, Algorithm SM-4 showed that the use of matrix of intervals leads to several problems that could easily be solved by replacing intervals with <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/O-factor" class=" wrap external" target="_blank" rel="nofollow noreferrer">O-factors</a></u>. Those additional flaws led to a fast implementation of <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Algorithm_SM-5" class=" wrap external" target="_blank" rel="nofollow noreferrer">Algorithm SM-5</a></u> yet in 1989. Here is a short analysis that explained the flaws in the use of the matrix of <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Optimum_interval" class=" wrap external" target="_blank" rel="nofollow noreferrer">optimum intervals</a></u>:</p><p>SM-4 表明，除了收敛速度慢以外，使用间隔矩阵会导致一些问题，而用 OF 来替换间隔可以很容易解决。这些额外的缺陷使 SM-5 快速实现。以下是使用最优间隔矩阵的缺陷：</p><blockquote>Archive warning: <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Why_use_literal_archives%253F" class=" wrap external" target="_blank" rel="nofollow noreferrer">Why use literal archives?</a></u><br>This text was part of: "<i>Optimization of learning</i>" by <u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Piotr_Wozniak" class=" wrap external" target="_blank" rel="nofollow noreferrer">Piotr Wozniak</a></u> (1990)<br>档案警告:<u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Why_use_literal_archives%253F" class=" wrap external" target="_blank" rel="nofollow noreferrer">为什么使用文字档案?</a></u><br>本文是<u><a href="http://link.zhihu.com/?target=https%3A//supermemo.guru/wiki/Piotr_Wozniak" class=" wrap external" target="_blank" rel="nofollow noreferrer">Piotr Wozniak</a></u>(1990)的《<i>优化学习</i>》的一部分。</blockquote><ul><li>In the course of repetition it may happen that one of the intervals will be calculated as shorter than the preceding one. This is certainly inconsistent with general assumptions leading to the SuperMemo method. Moreover, validity of such an outcome was refuted by the results of application of the Algorithm SM-5. This flaw could be prevented by disallowing intervals to increase or drop beyond certain values, but such an approach would tremendously slow down the optimization process interlinking optimal intervals by superfluous dependencies. The discussed case was indeed observed in one of the databases. The discrepancy was not eliminated by the end of the period in which the Algorithm SM-4 was used despite the fact that the intervals in question were only two weeks long</li><li>E-Factors of particular items are constantly modified thus in the OI matrix an item can pass from one difficulty category to another. If the repetition number for that item is large enough, this will result in serious disturbances of the repetitory process of that item. Note that the higher the repetition number, the greater the difference between optimal intervals in neighboring E-Factor category columns. Thus if the E-Factor increases the optimal interval used for the item can be artificially long, while in the opposite situation the interval can be much too short</li></ul><p><br></p><ul><li>在重复过程中，可能会发生一个间隔在计算后短与前一个间隔的情况，这与 SuperMemo 的假设不一致。此外，即使可以通过不允许间隔增加或减少超过某值来避免这种情况，但这会极大减慢矩阵的优化过程。</li><li>特定卡片的 EF 会不断修改，因此在 OI 矩阵中，一个卡片可以从一个难度类别转移到另一个难度类别。如果卡片重复的次数足够大，将会导致卡片重复过程的严重影响。注意，卡片连续重复次数越大，相邻的 EF 列的最优间隔间的差异就越大。英雌，如果 EF 增加，卡片的最优间隔会变得不自然的长，在相反的情况下间隔可能会变得太短。</li></ul><p>The Algorithm SM-4 tried to interrelate the length of the optimal interval with the repetition number. This approach seems to be incorrect because the memory is much more likely to be sensitive to the length of the previously applied inter-repetition interval than to the number of the repetition</p><p>SM-4 尝试将最优间隔的长度和重复次数相关联。这种方法似乎是不正确的。因为记忆对之前使用的重复间隔长度更敏感，而不是重复次数。</p><p></p>