<!DOCTYPE html>
<html lang="zh-CN">
<head>
<title>用间隔重复软件记住一门编程语言 - @Thoughts Memo</title>
<meta charset="UTF-8">
<meta property="og:type" content="website">
<meta property="og:title" content="用间隔重复软件记住一门编程语言 - @Thoughts Memo">
<meta property="og:site_name" content="ZhiHu Archive for Thoughts Memo">
<meta property="og:url" content="https://zhuanlan.zhihu.com/p/594372725">
<meta name="description" property="og:description" content="这件事我已经做了一年了，这是我 14 年的编程经历中最有帮助的学习技巧。背景：我是…">
<meta property="twitter:card" content="summary">
<meta name="twitter:title" property="og:title" itemprop="name" content="用间隔重复软件记住一门编程语言 - @Thoughts Memo">
<meta name="twitter:description" property="og:description" itemprop="description" content="这件事我已经做了一年了，这是我 14 年的编程经历中最有帮助的学习技巧。背景：我是…">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no">
<meta name="google-site-verification" content="U7ZAFUgGNK60mmMqaRygg5vy-k8pwbPbDFXNjDCu7Xk" />
<link rel="alternate" type="application/rss+xml" title="ZhiHu Archive for Thoughts Memo" href="https://l-m-sherlock.github.io/ZhiHuArchive/feed.xml">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/yue.css@0.4.0/yue.css">
<script>
</script>
<style>
.origin_image {
width: 100%;
}
figure {
margin:1.4em 0;
}
figure img {
width: 100%;
}
img {
vertical-align: middle;
}
.author {
display: flex;
gap: 1em;
}
#avatar {
width: 100px;
height: 100px;
}
.author > div {
flex: 1;
}
a[data-draft-type="link-card"] {
   display: block;
}
</style>
</head>
<body style="max-width: 1000px; margin: 0 auto; padding: 0 1em 0 1em;" class="yue">
<p><a href="./">← 返回目录</a></p>
<hr>
<header>
<img class="origin_image" src="https://picx.zhimg.com/v2-cd624a1bff5c5f4814cde8d2752805d9_720w.jpg?source=b1748391"/>
<h1><a href="https://zhuanlan.zhihu.com/p/594372725">用间隔重复软件记住一门编程语言</a></h1>
<div class="author">
<img class="avatar" id="avatar" src="https://picx.zhimg.com/50/v2-f958f2b875b0cf4d7ee853e4446ba2d1_l.jpg?source=b1748391" />
<div>
<h2 rel="author">
<a href="https://api.zhihu.com/people/4c592f496dc33822b560b382907ff1d0" target="_blank">@Thoughts Memo</a>
</h2>
<p> 学校≠教育≠技能；文凭溢价=80%信号传递+20%人力资本 </p>
</div>
</div>
<time datetime="2022-12-26T04:24:44">发表于 2022年12月26日</time>
<p rel="stats"style="color: #999; font-size: 0.9em;">201 👍 / 40 💬</p>
</header>
<article>
<p data-pid="Y41OZXsl">这件事我已经做了一年了，这是<b>我 14 年的编程经历中最有帮助的学习技巧</b>。</p><h2>背景：</h2><p data-pid="GIuzSmnk">我是一个中等水平的程序员，没有为此去上学。我只在必要时学习，因为我搭建了一个网站，而这个网站越来越火，我又雇不起程序员，所以我只好拿起几本关于 PHP、SQL、Linux 和 Apache 的书，学到的东西只够让网站工作，然后用这些小知识做了好几年。</p><p data-pid="PxcA-OC7">但是后来，我和一位专业的程序员一同工作，我被他的专业水平折服了！所有这些命令和函数从他指尖毫不费力的流出。我们使用同一门编程语言，但是<b>他掌握的实在是太多了</b>，以至于我感觉就像一个懵懂小孩与大学教授坐在一起。我非常想达到那种熟练程度。</p><p data-pid="Ogo30JyI">这引起了我的思考：这些年里，有多少知识是我<b>学习过又很快忘记的</b>。我阅读了很多书和文章，学习过许多有用的知识点，并且立刻实践。但是后来我分了心，忘记了那些知识，又重新回到了我原来做事的方式。</p><p data-pid="bUlwwtRp">我想深深地记住编程语言的命令和技巧，不忘记它们，以便在我需要的时候，它们能浮现在眼前。</p><h2>间隔重复：</h2><p data-pid="ssyaootp">当你听到一个新的事实，你容易很快忘记，除非它不断在你的脑海中重复。</p><p data-pid="aQpCBvBF">通过把自己沉浸在某门语言中你可以凑巧做到不断重复新学的内容，比如你学到的新词碰巧被提起。</p><p data-pid="-zvdprsK">但是对记忆的研究表明，<b>记住一个新事实最高效的时间恰好是你将遗忘它的时候</b>。</p><figure data-size="normal"><img class="origin_image zh-lightbox-thumb" data-original="https://pica.zhimg.com/v2-75b39eff360d196384b53ca2ece3cc9a_r.jpg" data-original-token="v2-75b39eff360d196384b53ca2ece3cc9a" data-rawheight="369" data-rawwidth="630" data-size="normal" src="https://pica.zhimg.com/v2-75b39eff360d196384b53ca2ece3cc9a_b.jpg" width="630"/><figcaption>遗忘曲线</figcaption></figure><p data-pid="8VzRtqRe">比方说，如果你学了一个外语的新单词，你在听完几分钟后再练习，然后是几个小时，第二天，然后是 2 天，5 天，然后是 10 天，3 周，6 周，3 个月，8 个月，等等。一段时间后，它基本上就被永久地记住了，只需偶尔提醒一下。</p><p data-pid="M-fzd1YO"><b>间隔重复软件就是这么帮助你的</b>，所以你只需<b>给间隔重复软件一系列你需要记忆的知识，然后一天做一次小测试，软件将根据你的反馈结果来确定复习间隔。</b>在每次小测试之后，如果你觉得容易，这个知识点在很长时间内都不会再重复。但如果你觉得被难住了，软件将在几分钟之内再次提问，直到你掌握了知识点。</p><p data-pid="Pra746bK"><b>到 <a class="wrap external" href="https://apps.ankiweb.net/" rel="nofollow noreferrer" target="_blank">apps.ankiweb.net</a> 并下载 Anki</b>。 这是个流行的免费开源间隔重复软件。</p><p data-pid="I8_071nM">至于编程，你知道我要说什么。</p><p data-pid="L75kG1tV">如果你能<b>记忆你所选择的编程语言的一切</b>呢？所有命令，每个参数，各种函数，大部分常见问题的每一个解决方案，都被你的指尖牢牢记住？想象一下，翻阅一篇文档或一本书，<b>永久地记住其中的每一个字</b></p><p data-pid="wUAsOoXl">介绍到此为止，我们来讨论一下如何做：</p><h2>首先，学起来！</h2><p data-pid="RLUEFLI1"><b>抽认卡片适用于*记住*所学知识。</b></p><p data-pid="KE1bco6O">在你建立某一知识的抽认卡片之前，其实你需要<b>学习并理解这个知识。</b>在你很好掌握之后再建立抽认卡片。</p><p data-pid="1vzjZQYa">（这就是为什么看别人的抽认卡片帮助不大的原因。抽认卡片只是用来辅助记忆的。）</p><h2>把知识转变成许多小的知识点：</h2><p data-pid="MadPANX0">在制作一系列抽认卡片的时候，在正面写上问题，在反面写上答案。</p><p data-pid="83nBcYF1">如果你只是用抽认卡片来记忆外语单词，那么抽认卡片的设计非常简单。在正面写上一个单词或短语，背面写上翻译，反之亦然。</p><figure data-size="normal"><img class="content_image" data-original-token="v2-ff602063fd764e35edace7763a561f76" data-rawheight="303" data-rawwidth="278" data-size="normal" src="https://pic3.zhimg.com/v2-ff602063fd764e35edace7763a561f76_b.jpg" width="278"/><figcaption>example chinese flash card question</figcaption></figure><figure data-size="normal"><img class="content_image" data-original-token="v2-c69373c97742eaabdd1540e7e63d05fc" data-rawheight="337" data-rawwidth="278" data-size="normal" src="https://pic1.zhimg.com/v2-c69373c97742eaabdd1540e7e63d05fc_b.jpg" width="278"/><figcaption>example chinese flash card answer</figcaption></figure><figure data-size="normal"><img class="content_image" data-original-token="v2-1681571215a0080d14dbaf644bf5d5ab" data-rawheight="350" data-rawwidth="278" data-size="normal" src="https://picx.zhimg.com/v2-1681571215a0080d14dbaf644bf5d5ab_b.jpg" width="278"/><figcaption>example chinese flash card question</figcaption></figure><figure data-size="normal"><img class="content_image" data-original-token="v2-1d457cbcac1bbd248171d9e377adbddd" data-rawheight="364" data-rawwidth="278" data-size="normal" src="https://pic4.zhimg.com/v2-1d457cbcac1bbd248171d9e377adbddd_b.jpg" width="278"/><figcaption>example chinese flash card answer</figcaption></figure><p data-pid="Dh5cT6_P">但是，如果你要学习其他东西，你就得在制作自己的抽认卡时投入一点技艺和创意。</p><p data-pid="tJYOtMWW">要花一些功夫来读你想记住的片段，挑出关键的事实，把它们分解成不可再分的最小片段，并把它们编成问题，用来考查未来的自己。</p><p data-pid="9XiUCLK3">以下是我一年来做这件事的省时建议：</p><h3>把散落的文字变成代码</h3><p data-pid="qkzRHG88">如果你在阅读一本关于编程的教程时，看到一段描述一个特性的文字。</p><blockquote data-pid="pMQAyFXb"> 「加法（+）运算符...如果只有一个操作数是字符串，另一个操作数被转为字符串，那么结果是两个字符串的连接。」</blockquote><p data-pid="F0oKOMeY">你自己测试了一下，玩了一下，就明白了。所以你做了一张抽认卡来记住它。</p><div class="highlight"><pre><code class="language-text">var a = 5 + '5';

 // a 的值是什么？</code></pre></div><p class="ztext-empty-paragraph"><br/></p><div class="highlight"><pre><code class="language-text">  '55'

  如果 + 号的任何一边是一个字符串，另一边就会

  先转换为字符串，再像字符串一样相加</code></pre></div><h3>尝试检测未来的自己</h3><p data-pid="ufPxLQsQ">有时你会学到一个 「疑点」——一个常见的错误或出人意料的特性。</p><blockquote data-pid="jYrafNqa"> 「如果向数组构造函数传递一个数字，它将按这个数字的长度来建立一个空数组。任何其他变量的组合都会创建一个包含这些变量的数组。」</blockquote><p data-pid="pycDTJmq">你自己测试一下，玩一玩，了解一下。然后做两张抽认卡，尝试检测一下未来的自己。</p><div class="highlight"><pre><code class="language-text">var a = new Array('5');

 // a 的值是什么？</code></pre></div><p class="ztext-empty-paragraph"><br/></p><div class="highlight"><pre><code class="language-text">  只有一个元素的数组，字符串 '5'：['5'];</code></pre></div><p data-pid="jXyo3CqO">...然后是几乎一模一样的问题...</p><div class="highlight"><pre><code class="language-text">var a = new Array(5);

 // a 的值是什么？</code></pre></div><p class="ztext-empty-paragraph"><br/></p><div class="highlight"><pre><code class="language-text">  一个长度为 5 的空数组。</code></pre></div><p data-pid="wdGgyhWl">当程序对你进行测验时，卡片会被打乱，因此希望你的例子能有意地吸引你的注意力。</p><p data-pid="EmxbXM-4">你也可以尝试用更复杂的例子来检测自己，让这些问题在你脑海中记忆犹新：</p><div class="highlight"><pre><code class="language-text">var a = [20, 10, 5, 1];

 // a.sort() 的结果是什么？</code></pre></div><p class="ztext-empty-paragraph"><br/></p><div class="highlight"><pre><code class="language-text">  [1, 10, 20, 5]

  // sort 将所有值视为字符串</code></pre></div><p data-pid="8k7I0snp">不要忘记<b>用这个结果检测自己：</b></p><div class="highlight"><pre><code class="language-text">var a = [20, 10, 5, 1];

  // 按数值大小顺序排序</code></pre></div><p class="ztext-empty-paragraph"><br/></p><div class="highlight"><pre><code class="language-text">  function compare(v1, v2) { return(v1 — v2); }

  a.sort(compare);</code></pre></div><h3>保存很酷的技巧</h3><p data-pid="ofEzb0IH">如果你发现一个你想记住的很酷的技巧，可以把它变成一个小挑战的答案。</p><div class="highlight"><pre><code class="language-text">var albums = [

{name: 'Beatles', title: 'White Album', price: 15},

{name: 'Zeppelin', title: 'II', price: 7}];

 // 让下面的代码能够运行：

  albums.sort(by('name'));

  albums.sort(by('title'));

  albums.sort(by('price'));</code></pre></div><p class="ztext-empty-paragraph"><br/></p><div class="highlight"><pre><code class="language-text">  function by(propName) {

return function(obj1, obj2) {

  v1 = obj1[propName];

  v2 = obj2[propName];

  if (v1 &lt; v2) { return -1; }

  else if (v1 &gt; v2) { return 1; }

  else { return 0; }

};

  }</code></pre></div><h3>要求包含多种解决方案的答案</h3><p data-pid="H5bn8whk">如果做某事有不止一种方法，而你想把它们都记住，以便将来能想出不止一种解决方案，那么你可以把两种方案都记在脑海中。</p><div class="highlight"><pre><code class="language-text">s = 'string like this'

  # 在 Ruby 中，展示两种把它变成 'String Like This' 的方法</code></pre></div><p class="ztext-empty-paragraph"><br/></p><div class="highlight"><pre><code class="language-text">  s.split.map(&amp;:capitalize).join(' ')

  s.gsub(/\b\S/) {|x| x.upcase}</code></pre></div><h3>把宽泛的概念变成言简意赅的例子</h3><p data-pid="QZcqxkOZ">假设你刚刚花了 20 分钟学习一些概念性较强的知识，没那么多具体的功能需要记住。这时你只需要一个简洁的例子来提醒自己这个概念。</p><div class="highlight"><pre><code class="language-text">/(a(b)((c)d))/.match('abcd')

  # $1, $2, $3, $4 的值是什么?</code></pre></div><p class="ztext-empty-paragraph"><br/></p><div class="highlight"><pre><code class="language-text">  $1 = 'abcd'

  $2 = 'b'

  $3 = 'cd'

  $4 = 'c'</code></pre></div><p data-pid="5olM8yjt">其他例子：</p><div class="highlight"><pre><code class="language-text">class C

self

  end

  class D &lt; C

  end

  d1 = D.new

  # 哪一个对象是 self？</code></pre></div><p class="ztext-empty-paragraph"><br/></p><div class="highlight"><pre><code class="language-text">  class D</code></pre></div><h3>阅读彼得·沃兹尼亚克所著的《<a class="wrap external" href="https://www.supermemo.com/en/articles/20rules" rel="nofollow noreferrer" target="_blank">知识表述的 20 条规则</a><sup data-draft-node="inline" data-draft-type="reference" data-numero="1" data-text="有效的学习：处理知识的20条规则" data-url="https://www.yuque.com/supermemo/wiki/20rules">[1]</sup>》</h3><p data-pid="XHm6BJgA">有关制卡的最佳建议出自一篇名为《知识表述的 20 条规则》的文章，作者是彼得·沃兹尼亚克 ，网址：<a class="wrap external" href="https://www.supermemo.com/en/articles/20rules" rel="nofollow noreferrer" target="_blank">supermemo.com/en/articles/20rules</a>。希望大家能读一下。</p><h2>每日练习</h2><p data-pid="yDtjsdsn">为了达到最佳效果，你需要每天打开一次间隔重复软件。如果你太久没有这样做，你将前功尽弃，并且不得不重新学习你本应记住的东西。</p><p data-pid="ARNQcD45"><b>只需要每天 20 分钟，你可以记住成千上万条知识。</b>我把它当作早晨的例行事项。泡一杯茶，用一会儿 Anki，然后喝茶。</p><p data-pid="gVZQCZNi">在你测试自己时产生肾上腺素，让自己以最快的速度前进，是一件非常有趣的事情。</p><p data-pid="HX2PHnTx">这就像一种去精神健身房的旅程。每天 20 分钟的小强度训练，无论是考虑眼前还是长期的影响都很值当。</p><p data-pid="e_n5XZU6">随时增加新卡片，你将会惊喜地发现所有知识都清晰地印在你的脑海中。</p><h2>总结</h2><p data-pid="-LdT5l5p">我已经这样练习了一年，这大大促进了我写代码的流畅度。如你所见，我强烈推荐这个方法。</p><p data-pid="ZkdR5sc6">你可以<a class="wrap external" href="https://sive.rs/contact" rel="nofollow noreferrer" target="_blank">向我发邮件</a>来让我知道这种方法对你效果如何。</p><h2>进一步阅读：</h2><p data-pid="vwRx103H"><a class="wrap external" href="https://www.jackkinsella.ie/articles/janki-method-refined" rel="nofollow noreferrer" target="_blank">Jack Kinsella 所著的《JAnki：写给程序员们的 13 条 Anki 使用经验》</a><sup data-draft-node="inline" data-draft-type="reference" data-numero="2" data-text="JAnki：写给程序员们的 13 条 Anki 使用经验" data-url="https://zhuanlan.zhihu.com/p/412012134">[2]</sup>是一篇关于相同方法的好文章，有些地方比我写得更好。</p><p data-pid="GHUAJbxK">你可以用 Anki 来学习<a class="wrap external" href="https://quantifiedself.com/blog/spaced-repetition-and-learning/" rel="nofollow noreferrer" target="_blank">所有知识</a>。</p><p data-pid="eG-1gF8y"><a class="wrap external" href="http://augmentingcognition.com/ltm.html" rel="nofollow noreferrer" target="_blank">Michael Nielsen 所著的《增强长期记忆》</a><sup data-draft-node="inline" data-draft-type="reference" data-numero="3" data-text="量子物理学家是如何使用 Anki 的？" data-url="https://zhuanlan.zhihu.com/p/65131722">[3]</sup>是一篇讲述用 Anki 学习任何知识的好文章。</p><p data-pid="q81L5je_">阅读<a class="wrap external" href="https://www.wired.com/2008/04/ff-wozniak/" rel="nofollow noreferrer" target="_blank">《连线》对彼得·沃兹尼亚克的访谈</a> ——把这个方法推向极限的人的故事。</p><p data-pid="doZHPRg9">© 2013 <a class="wrap external" href="https://sive.rs/" rel="nofollow noreferrer" target="_blank">Derek Sivers</a>.</p><h2>Copy &amp; share: <a class="wrap external" href="https://sive.rs/srs" rel="nofollow noreferrer" target="_blank">sive.rs/srs</a></h2><p class="ztext-empty-paragraph"><br/></p><blockquote data-pid="BzFD1hjA"><a class="wrap external" href="http://paratranz.cn/projects/3131" rel="nofollow noreferrer" target="_blank">Thoughts Memo</a> 汉化组译制<br/>感谢主要译者 Lucas-Tsui、校对燕汝成<br/>原文：<a class="wrap external" href="https://sive.rs/srs" rel="nofollow noreferrer" target="_blank">Memorizing a programming language using spaced repetition software | Derek Sivers</a><br/>发布于 2013-01-06</blockquote>
<hr><section><h2>参考</h2>1. 有效的学习：处理知识的20条规则 <a href="https://www.yuque.com/supermemo/wiki/20rules">https://www.yuque.com/supermemo/wiki/20rules</a><br>2. JAnki：写给程序员们的 13 条 Anki 使用经验 <a href="./412012134.html">./412012134.html</a><br>3. 量子物理学家是如何使用 Anki 的？ <a href="https://zhuanlan.zhihu.com/p/65131722">https://zhuanlan.zhihu.com/p/65131722</a></section>
<hr>
<div class="column" style="margin: 1em 0; padding: 0.5em 1em; border: 2px solid #999; border-radius: 5px;">
<h2>专栏：Thoughts Memo的文章</h2>
</div>
<hr>
<p><a href="./">← 返回目录</a></p>
</article>
<script src="https://giscus.app/client.js"
data-repo="L-M-Sherlock/ZhiHuArchive"
data-repo-id="MDEwOlJlcG9zaXRvcnkzNDk5NDE0MzM="
data-category="Announcements"
data-category-id="DIC_kwDOFNuuuc4Ck92x"
data-mapping="title"
data-strict="0"
data-reactions-enabled="1"
data-emit-metadata="0"
data-input-position="top"
data-theme="preferred_color_scheme"
data-lang="zh-CN"
data-loading="lazy"
crossorigin="anonymous"
async>
</script>
</body>
</html>